<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>bfhelper.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BigFraction_BigFraction.html">BigFraction</a></li><li><a href="Complex.html">Complex</a><ul class='methods'><li data-type='method'><a href="Complex.html#abs">abs</a></li><li data-type='method'><a href="Complex.html#arg">arg</a></li><li data-type='method'><a href="Complex.html#conj">conj</a></li><li data-type='method'><a href="Complex.html#exp">exp</a></li><li data-type='method'><a href="Complex.html#isAlmostZero">isAlmostZero</a></li><li data-type='method'><a href="Complex.html#log">log</a></li></ul></li><li><a href="Poly.html">Poly</a><ul class='methods'><li data-type='method'><a href="Poly.html#_checkSeries">_checkSeries</a></li><li data-type='method'><a href="Poly.html#_divEuclidean">_divEuclidean</a></li><li data-type='method'><a href="Poly.html#_divSeries">_divSeries</a></li><li data-type='method'><a href="Poly.html#_sinCosV">_sinCosV</a></li><li data-type='method'><a href="Poly.html#_splitConst">_splitConst</a></li><li data-type='method'><a href="Poly.html#acos">acos</a></li><li data-type='method'><a href="Poly.html#asin">asin</a></li><li data-type='method'><a href="Poly.html#atan">atan</a></li><li data-type='method'><a href="Poly.html#cos">cos</a></li><li data-type='method'><a href="Poly.html#degree">degree</a></li><li data-type='method'><a href="Poly.html#deriv">deriv</a></li><li data-type='method'><a href="Poly.html#div">div</a></li><li data-type='method'><a href="Poly.html#equals">equals</a></li><li data-type='method'><a href="Poly.html#eval">eval</a></li><li data-type='method'><a href="Poly.html#exp">exp</a></li><li data-type='method'><a href="Poly.html#integ">integ</a></li><li data-type='method'><a href="Poly.html#log">log</a></li><li data-type='method'><a href="Poly.html#pow">pow</a></li><li data-type='method'><a href="Poly.html#powSeries">powSeries</a></li><li data-type='method'><a href="Poly.html#sin">sin</a></li><li data-type='method'><a href="Poly.html#tan">tan</a></li><li data-type='method'><a href="Poly.html#valuation">valuation</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#Flags">Flags</a></li><li><a href="global.html#bigIntSqrt">bigIntSqrt</a></li><li><a href="global.html#fminbnd">fminbnd</a></li><li><a href="global.html#fromDouble">fromDouble</a></li><li><a href="global.html#fzero">fzero</a></li><li><a href="global.html#gcd">gcd</a></li><li><a href="global.html#ode45">ode45</a></li><li><a href="global.html#poly">poly</a></li><li><a href="global.html#polyfit">polyfit</a></li><li><a href="global.html#polyval">polyval</a></li><li><a href="global.html#romberg">romberg</a></li><li><a href="global.html#roots">roots</a></li><li><a href="global.html#solveLinearSystem">solveLinearSystem</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">bfhelper.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as bfjs from "./bf.js";
import { Complex } from "./bf.js";
/**
 * High-precision Numerical Integration using Romberg's Method.
 * 
 * This function estimates the definite integral of `f` over the interval `[_a, _b]` 
 * using Richardson extrapolation applied to the Trapezoidal rule.
 * It iteratively refines the interval width and the order of the polynomial approximation 
 * to achieve high precision with relatively few function evaluations.
 *
 * @param {Function} f - The integrand function.
 *        Must accept a BigFloat argument (x) and return a BigFloat result (f(x)).
 *
 * @param {number|string|BigFloat} _a - The lower limit of integration.
 * @param {number|string|BigFloat} _b - The upper limit of integration.
 *
 *
 * @param {Object} [info={}] - Configuration and Status object.
 *        Configures execution parameters and stores statistical data during/after execution.
 * @param {number} [info._e=1e-30] - Absolute Error Tolerance.
 *        The integration stops when the estimated absolute error falls below this threshold.

 * @param {number} [info._re=info._e] - Relative Error Tolerance.
 *        The integration stops when the estimated relative error falls below this threshold.
 *        (Condition: error &lt;= _e || rerror &lt;= _re)
 *        // --- Input Configuration Properties ---
 * @param {number} [info.max_step=25] - Maximum number of interval halving steps (rows in the Romberg table).
 *        Note: The number of function evaluations grows exponentially (2^steps).
 * @param {number} [info.max_acc=12] - Maximum extrapolation order (columns in the Romberg table).
 *        Limits the depth of Richardson extrapolation to prevent numerical instability from high-order polynomials.
 * @param {number} [info.max_time=60000] - Maximum execution time in milliseconds.
 * @param {Function} [info.cb] - Optional callback function executed after each row of the table is computed.
 * @param {boolean} [info.debug] - Optional flag to enable debug logging to the console.
 *
 *        // --- Output Status Properties (Updated during execution) ---
 * @param {BigFloat|null} info.result - The final calculated integral.
 *        Returns a BigFloat if converged, or null if failed.
 * @param {BigFloat} info.lastresult - The best estimate of the integral from the most recent iteration.
 * @param {string} info.eff_result - String representation of the result based on effective precision.
 * @param {number} info.steps - Current iteration number (row index `m`).
 *        Corresponds to dividing the interval into 2^(steps-1) segments.
 * @param {number} info.exectime - Elapsed execution time in milliseconds.
 * @param {BigFloat} info.error - Estimated absolute error.
 *        Calculated as the difference between the two most accurate extrapolations in the current row.
 * @param {BigFloat} info.rerror - Estimated relative error (`error / lastresult`).
 * @param {number} info.eff_decimal_precision - Estimated number of significant decimal digits.
 *        Calculated as `-log10(rerror)`.
 * @param {Function} info.toString - Helper method.
 *        Returns a formatted string containing steps, error, result, and execution time.
 *
 * @returns {BigFloat|null} 
 *        Returns the BigFloat integral value if tolerances are met.
 *        Returns `null` if `max_step` or `max_time` is reached without convergence.
 */
export function romberg(f,_a,_b,info={}){
    let max_step=info.max_step||25,
        max_acc=info.max_acc||12,
        max_time=info.max_time||60000;
    let _e  = info._e ?? 1e-30;
    let _re = info._re ?? _e;
    if(typeof(_e)!='number'|| typeof(_re)!='number' || typeof(info)!="object"){
        throw new Error("arguments error");
    }
    let start_time=new Date().getTime();
    info.toString=function(){
        return `lastresult=${this.lastresult}, 
        effective_result=${this.eff_result},
        steps=${this.steps}/${max_step}, 
        error=${this.error.toString(10,3)},
        rerror=${this.rerror.toString(10,3)},
        eff_decimal_precision=${this.eff_decimal_precision}, 	  
        exectime=${this.exectime}/${max_time}`
        };

    let a=bfjs.bf(_a),b=bfjs.bf(_b),e=bfjs.bf(_e),re=bfjs.bf(_re);

    let sign=b.cmp(a);
    if(sign&lt;0){
        let tmp=a;
        a=b;
        b=tmp;
    }
    var updateInfo=()=>{
        if(info.rerror.isZero()){
            info.eff_decimal_precision=bfjs.decimal_precision();
        }else{
            info.eff_decimal_precision=Math.floor(-info.rerror.log().f64()/Math.log(10));
        }
        if(info.eff_decimal_precision&lt;=0){
            info.eff_decimal_precision=0;
            info.eff_result='';
        }else{
            if(info.eff_decimal_precision>bfjs.decimal_precision()){
                info.eff_result=info.lastresult.toString(10);
            }else{
                info.eff_result=info.lastresult.toString(10,info.eff_decimal_precision);
            }		
        }
    };

    const f0p5=bfjs.bf(0.5);  
    const b_a_d=b.sub(a).mul(f0p5);
    let T=[0,b_a_d.mul(f(a).add(f(b)))];
    for(let m=2;m&lt;=max_step;++m){  
        let Tm=[];    
        let sum=bfjs.bf(0);
        for(let i=0;i&lt;2**(m-2)/*do not overflow*/;++i){
        sum.setadd(sum,f(a.add(b_a_d.mul(i*2+1))));
        }
        Tm[1]=T[1].mul(f0p5).add(b_a_d.mul(sum));
        b_a_d.setmul(b_a_d,f0p5);
        for(let j=2;j&lt;=max_acc &amp;&amp; j&lt;=m;++j){
        let c=bfjs.bf(4**(j-1)),c1=bfjs.bf(4**(j-1)-1);
        Tm[j]=Tm[j-1].mul(c).sub(T[j-1]).div(c1);
        }
        let err=Tm[Tm.length-1].sub(T[T.length-1]).abs();
        let rerr;
        if(!Tm[Tm.length-1].isZero()){
            rerr=err.div(Tm[Tm.length-1].abs());
        }else{
            rerr=err;
        }
        if(!!info.debug &amp;&amp; m>5){    	
            console.log('R['+m+']='+Tm[4]);
            console.log(err.toString(10,3));
        }

        info.exectime=new Date().getTime()-start_time;
        info.lastresult=Tm[Tm.length-1];
        if(sign&lt;0){
            info.lastresult=info.lastresult.neg();
        }
        info.steps=m;
        info.error=err;
        info.rerror=rerr; 

        if(m>5 &amp;&amp; (err.cmp(e)&lt;=0 || rerr.cmp(re)&lt;=0)){
            info.result=info.lastresult;
            updateInfo();
            return info.result;
        }else if(m==max_step || info.exectime>max_time){
            updateInfo();
            info.result=null;
            return info.result;
        }

        if(info.cb){
            updateInfo();
            info.cb();
        }
        T=Tm;
    }
}



/**
 * High-precision Root Finding using the Brent-Dekker Method (similar to MATLAB's fzero).
 * 
 * This algorithm combines the reliability of Bisection, the speed of the Secant method, 
 * and the high-order convergence of Inverse Quadratic Interpolation (IQI).
 * It guarantees global convergence while achieving superlinear convergence rates near the root.
 *
 * @param {Function} f - The target function to find the root of. 
 *        Must accept a BigFloat argument and return a BigFloat result.
 *        The function values at the endpoints must have opposite signs (f(_a) * f(_b) &lt;= 0).
 *
 * @param {number|string|BigFloat} _a - The start of the search interval (or first initial guess).
 * @param {number|string|BigFloat} _b - The end of the search interval (or second initial guess).
 *
 *
 * @param {Object} [info={}] - Configuration and Status object.
 *        This object configures the execution parameters and is updated in-place 
 *        with statistical data during and after execution.
 * @param {number|string|BigFloat} [info._e=1e-30] - Absolute Error Tolerance.
 *        Convergence is considered achieved when the interval width or step size falls below this value.
 *
 * @param {number|string|BigFloat} [info._re=info._e] - Relative Error Tolerance.
 *        Used to handle convergence for large values. Defaults to the absolute tolerance.
 *        The effective tolerance is calculated as: `tol = |b| * _re + _e`.
 * 
 *        // --- Input Configuration Properties ---
 * @param {number} [info.max_step=200] - Maximum number of iterations allowed.
 *        If this limit is reached without convergence, the function returns null and logs a warning.
 * @param {number} [info.max_time=60000] - Maximum execution time in milliseconds.
 *        Prevents the function from hanging in infinite loops or extremely slow computations.
 * @param {Function} [info.cb] - Optional callback function.
 *        If defined, this function is called after every iteration. Useful for updating UI progress or logging.
 * @param {boolean} [info.debug] - Optional flag to enable debug logging (implementation dependent).
 *
 *        // --- Output Status Properties (Updated during execution) ---
 * @param {BigFloat|null} info.result - The final found root.
 *        Returns a BigFloat if converged, or null if failed.
 * @param {BigFloat} info.lastresult - The result of the last iteration (current best guess `b`).
 *        Even if convergence fails, this contains the value closest to the root when execution stopped.
 * @param {string} info.eff_result - String representation of the result based on effective precision.
 *        Generated by truncating `lastresult` according to `eff_decimal_precision`.
 * @param {number} info.steps - The number of iterations currently executed.
 * @param {number} info.exectime - The elapsed execution time in milliseconds.
 * @param {BigFloat} info.error - The estimated error bound.
 *        Typically represents half the width of the current search interval (`xm`).
 * @param {BigFloat} info.residual - The absolute value of the function at the current best guess: `|f(x)|`.
 *        Ideally, this value should be close to zero.
 * @param {number} info.eff_decimal_precision - Estimated number of significant decimal digits.
 *        Calculated as `-log10(error)`.
 * @param {Function} info.toString - Helper method.
 *        Returns a formatted string containing steps, error, residual, and execution time.
 *
 * @returns {BigFloat|null} 
 *        Returns the BigFloat root if the tolerance criteria are met.
 *        Returns `null` if the maximum steps or time limit is exceeded (a warning is logged to the console).
 */
export function fzero(f, _a, _b, info = {}) {
    let _e  = info._e ?? 1e-30;
    let _re = info._re ?? _e;

    // 1. Configuration &amp; Constants
    // Default steps for root finding (usually faster than integration, but high precision needs more)
    let max_step = info.max_step || 200,
        max_time = info.max_time || 60000;

    if (typeof(_e) !== 'number' || typeof(_re) !== 'number' || typeof(info) !== "object") {
        throw new Error("arguments error");
    }

    const start_time = new Date().getTime();

    // Cache BigFloat constants to avoid repeated object creation
    const bf_zero = bfjs.zero;
    const bf_one = bfjs.one;
    const bf_two = bfjs.two;
    const bf_three = bfjs.three;
    const bf_half = bfjs.half;

    // Initial Interval
    let a = bfjs.bf(_a);
    let b = bfjs.bf(_b);
    let fa = f(a);
    let fb = f(b);

    // Initial check: f(a) and f(b) must have opposite signs
    if (fa.mul(fb).cmp(bf_zero) > 0) {
        throw new Error("Function values at the interval endpoints must differ in sign.");
    }

    // `c` is the "contrapoint" (last point with opposite sign to b).
    // In Brent's method, the root is always bracketed between b and c.
    let c = a;
    let fc = fa;
    let d = b.sub(a); // Step size
    let e = d; // Previous step size
    
    // Tolerances
    let tol_act = bfjs.bf(_e);
    let tol_rel = bfjs.bf(_re);

    // Helper to sync local variables to info object (Performance optimization)
    const updateInfo = (iter, errorBound, residual) => {
        info.exectime = new Date().getTime() - start_time;
        info.steps = iter;
        info.lastresult = b; // Current best guess
        info.residual = residual;
        info.error = errorBound;
        
        // Calculate effective decimal precision
        // Handle log(0) explicitly
        if (errorBound.cmp(bf_zero) === 0) {
             info.eff_decimal_precision = bfjs.decimal_precision();
        } else {
             info.eff_decimal_precision = Math.floor(-errorBound.log().f64() / Math.log(10));
        }

        if (info.eff_decimal_precision &lt;= 0) {
            info.eff_decimal_precision = 0;
            info.eff_result = '';
        } else {
            let limit = bfjs.decimal_precision();
            let prec = info.eff_decimal_precision > limit ? limit : info.eff_decimal_precision;
            info.eff_result = b.toString(10, prec);
        }
    };

    // Format output string
    info.toString = function() {
        return `root=${this.eff_result}, 
      residual=${this.residual ? this.residual.toString(10, 3) : 'N/A'},
      steps=${this.steps}/${max_step}, 
      error=${this.error ? this.error.toString(10, 3) : 'N/A'},
      eff_prec=${this.eff_decimal_precision}, 	  
      exectime=${this.exectime}/${max_time}`;
    };

    // 2. Main Loop
    for (let iter = 1; iter &lt;= max_step; ++iter) {
        
        // Ensure |f(b)| &lt;= |f(c)|. b is always the best guess.
        if (fb.abs().cmp(fc.abs()) > 0) {
            a = c; fa = fc;
            c = b; fc = fb;
            b = a; fb = fa;
        }

        // Convergence tolerances
        // tol1 = |b| * tol_rel + tol_act
        let tol1 = b.abs().mul(tol_rel).add(tol_act); 
        let xm = c.sub(b).mul(bf_half); // Midpoint relative to b
        let xm_abs = xm.abs();

        // Check Convergence
        // 1. Interval size is smaller than tolerance
        // 2. Function value is exactly zero
        if (xm_abs.cmp(tol1) &lt;= 0 || fb.cmp(bf_zero) === 0) {
            updateInfo(iter, xm_abs, fb.abs());
            info.result = b;
            return b;
        }

        // Call callback if exists (sync info first)
        if (info.cb) {
            updateInfo(iter, xm_abs, fb.abs());
            info.cb();
        }

        // Check timeout
        if (new Date().getTime() - start_time > max_time) {
            updateInfo(iter, xm_abs, fb.abs());
            console.log("fzero: Timeout reached.");
            info.result = null;
            return null;
        }

        // Determine Step Strategy
        // Attempt Inverse Quadratic Interpolation (IQI) or Secant if:
        // 1. Previous step was large enough (|e| >= tol1)
        // 2. Function value decreased enough (|fa| > |fb|)
        if (e.abs().cmp(tol1) >= 0 &amp;&amp; fa.abs().cmp(fb.abs()) > 0) {
            let s = fb.div(fa);
            let p, q;

            // If a == c, we only have 2 distinct points -> Secant Method
            if (a.cmp(c) === 0) {
                // p = 2 * xm * s
                // q = 1 - s
                p = xm.mul(bf_two).mul(s);
                q = bf_one.sub(s);
            } else {
                // We have 3 distinct points -> Inverse Quadratic Interpolation
                let q_iqi = fa.div(fc);
                let r_iqi = fb.div(fc);
                
                // p = s * (2.0 * xm * q * (q - r) - (b - a) * (r - 1.0))
                let term1 = xm.mul(bf_two).mul(q_iqi).mul(q_iqi.sub(r_iqi));
                let term2 = b.sub(a).mul(r_iqi.sub(bf_one));
                p = s.mul(term1.sub(term2));
                
                // q = (q - 1.0) * (r - 1.0) * (s - 1.0)
                q = q_iqi.sub(bf_one).mul(r_iqi.sub(bf_one)).mul(s.sub(bf_one));
            }

            // Adjust signs so q > 0 to simplify division logic
            if (p.cmp(bf_zero) > 0) {
                q = q.neg();
            } else {
                p = p.neg();
            }
            q = q.abs();

            // Validate Interpolation
            // Condition 1: Must be within the interval (bounded by 3*xm*q - |tol1*q|)
            // Condition 2: Must converge faster than bisection (p &lt; |0.5*e*q|)
            let cond1_bound = xm.mul(bf_three).mul(q).sub(tol1.mul(q).abs());
            let cond2_bound = e.mul(q).abs().mul(bf_half);

            if (p.mul(bf_two).cmp(cond1_bound) &lt; 0 &amp;&amp; p.cmp(cond2_bound) &lt; 0) {
                // Accept Interpolation Step
                e = d;
                d = p.div(q);
            } else {
                // Reject, use Bisection
                d = xm;
                e = d;
            }
        } else {
            // Bounds too slow or not converging fast enough -> Bisection
            d = xm;
            e = d;
        }

        // Apply Step
        a = b;
        fa = fb;

        // Ensure step is at least tol1 (to avoid underflow/stagnation near root)
        if (d.abs().cmp(tol1) > 0) {
            b = b.add(d);
        } else {
            // b += sign(xm) * tol1
            let signXm = xm.cmp(bf_zero) >= 0 ? bf_one : bf_one.neg();
            b = b.add(tol1.mul(signXm));
        }

        fb = f(b);

        // Maintain Bracket: If fb and fc have same sign, reset c to a
        // (Root must always be between b and c)
        if (fb.cmp(bf_zero) === 0 || fb.mul(fc).cmp(bf_zero) > 0) { 
            c = a;
            fc = fa;
            d = b.sub(a);
            e = d;
        }
    }

    // 3. Exit (Max steps reached)
    // Update info one last time before failure
    let final_xm = c.sub(b).mul(bf_half).abs();
    updateInfo(max_step, final_xm, fb.abs());
    
    console.log(`fzero: Failed to converge after ${max_step} steps. Residual: ${fb.toString(10,3)}`);
    info.result = null; 
    return null;
};



/**
 * Calculates the roots of a polynomial with high precision using the Durand-Kerner method.
 * 
 * This function mimics MATLAB's `roots` command but supports arbitrary precision BigFloat numbers.
 * It solves for `x` in the polynomial equation:
 * c[0]*x^n + c[1]*x^(n-1) + ... + c[n] = 0
 * 
 * The algorithm iterates simultaneously towards all `n` roots, naturally handling complex conjugate pairs.
 *
 * @param {Array&lt;number|string|BigFloat|Complex>} _coeffs - The polynomial coefficients.
 *        Must be ordered from highest degree to lowest (e.g., [1, -5, 6] for x^2 - 5x + 6).
 *        Leading zeros are automatically removed.
 * 
 * @param {Object} [info={}] - Configuration and Status object.
 * 
 *        // --- Input Configuration ---
 * @param {number} [info.max_step=500] - Maximum number of iterations. 
 *        Durand-Kerner usually converges quadratically, so 50-100 is typically sufficient for high precision.
 * @param {number} [info.max_time=60000] - Maximum execution time in milliseconds.
 * @param {number|string|BigFloat} [info._e=1e-30] - Convergence tolerance.
 *        The loop stops when the maximum change in any root position is smaller than this value.
 * @param {Function} [info.cb] - Optional callback function executed after each iteration.
 * 
 *        // --- Output Status (Updated during execution) ---
 * @param {Array&lt;{re:BigFloat, im:BigFloat}>|null} info.result - The final array of roots.
 * @param {number} info.steps - Current iteration count.
 * @param {number} info.exectime - Elapsed time in ms.
 * @param {BigFloat} info.error - The maximum correction (shift magnitude) applied in the last step.
 *        Used as a proxy for the current error bound.
 * @param {number} info.eff_decimal_precision - Estimated significant decimal digits based on convergence error.
 * @param {string} info.eff_result - A string summary of the first root (for debugging/display).
 * @param {Function} info.toString - Helper to print status summary.
 * 
 * @returns {Array&lt;Complex>|null} 
 *          Returns an array of objects representing complex numbers {re, im}.
 *          Returns `null` if the solver fails to converge within limits.
 */
export function roots(_coeffs, info = {}) {    
    // 1. Config &amp; Initialization
    let max_step = info.max_step || 500;
    let max_time = info.max_time || 60000;
    let tol = bfjs.bf(info._e || 1e-30);
    const start_time = new Date().getTime();

    // Constant helpers
    const zero = bfjs.zero;
    const one = bfjs.one;

    // 2. Pre-processing: Convert all inputs to Complex objects
    let rawPoly = _coeffs.map(c => new Complex(c));

    // Remove leading zeros (leading coefficient cannot be 0)
    while (rawPoly.length > 0 &amp;&amp; rawPoly[0].abs().cmp(zero) === 0) {
        rawPoly.shift();
    }

    let n = rawPoly.length - 1; // Degree

    // Update info helper
    const updateInfo = (iter, max_err, current_roots_arr) => {
        info.steps = iter;
        info.exectime = new Date().getTime() - start_time;
        info.error = max_err;
        
        // Calculate precision based on error
        let c=max_err.cmp(zero);
        if (c === 0) {
            info.eff_decimal_precision = bfjs.decimal_precision();
        } else if (c &lt; 0) {
            info.eff_decimal_precision = 0;
        } else {
            info.eff_decimal_precision = Math.floor(-max_err.log().f64() / Math.log(10));
        }
        if(info.eff_decimal_precision &lt; 0) info.eff_decimal_precision = 0;

        // Save result preview
        if (current_roots_arr) {
            info.lastresult = current_roots_arr;
            // Format string for first root
            let prec = Math.min(info.eff_decimal_precision, 10);
            info.eff_result = current_roots_arr[0].toString(10, prec) + ` ...(${n} roots)`;
        }
    };

    info.toString = function() {
        return `degree=${n}, 
      error=${this.error ? this.error.toString(10, 3) : 'N/A'},
      steps=${this.steps}/${max_step}, 
      eff_prec=${this.eff_decimal_precision},
      exectime=${this.exectime}/${max_time}`;
    };

    // Edge Cases
    if (n &lt; 1) return []; // Empty or Constant
    if (n === 1) {
        // Linear: a*z + b = 0  =>  z = -b/a
        // coeffs are [a, b]
        let root = rawPoly[1].div(rawPoly[0]).neg();
        let res = [root];
        info.result = res;
        updateInfo(1, zero, res);
        return res;
    }

    // 3. Normalization (Make Monic)
    // P(z) = z^n + a[1]z^(n-1) + ... + a[n]
    // where a[i] = coeffs[i] / coeffs[0]
    // We store 'a' array such that index matches power offset or simply 1..n
    let a = []; 
    let c0 = rawPoly[0];
    for (let i = 1; i &lt;= n; i++) {
        a.push(rawPoly[i].div(c0));
    }

    // 4. Initialization (Aberth's Initial Guess)
    // Place roots on a circle: R * exp(i * theta)
    // Radius R = 1 + max(|a_i|)
    let max_coeff_mag = zero;
    for (let coeff of a) {
        let m = coeff.abs();
        if (m.cmp(max_coeff_mag) > 0) max_coeff_mag = m;
    }
    let radius = one.add(max_coeff_mag);
    
    // Initial roots
    let current_roots = [];
    const pi = bfjs.bf(Math.PI);
    const two_pi = pi.mul(bfjs.bf(2));
    const offset = bfjs.bf(0.7); // Avoid symmetries
    
    for (let k = 0; k &lt; n; k++) {
        let theta = two_pi.mul(bfjs.bf(k)).div(bfjs.bf(n)).add(offset);
        current_roots.push(Complex.fromPolar(radius, theta));
    }

    let max_change = zero;
    // 5. Durand-Kerner Iteration Loop
    for (let iter = 1; iter &lt;= max_step; ++iter) {
        max_change = zero;

        let next_roots = new Array(n);

        for (let i = 0; i &lt; n; i++) {
            let z = current_roots[i];

            // A. Evaluate P(z) using Horner's Method for Monic Polynomial
            // P(z) = (...((z + a_1)*z + a_2)*z + ... + a_n
            // Note: a[0] in our 'a' array corresponds to coeff of z^(n-1) (which is P_1)
            
            let p_val = z.add(a[0]); // First step: z + a_1
            for (let j = 1; j &lt; n; j++) {
                p_val = p_val.mul(z).add(a[j]);
            }
            
            // B. Calculate Denominator: Product_{j != i} (z_i - z_j)
            let denom = new Complex(1, 0);
            for (let j = 0; j &lt; n; j++) {
                if (i === j) continue;
                denom = denom.mul(z.sub(current_roots[j]));
            }

            // C. Calculate Shift
            // shift = P(z) / Product
            let shift = p_val.div(denom);
            
            // D. Update
            next_roots[i] = z.sub(shift);

            // Track convergence
            let change = shift.abs();
            if (change.cmp(max_change) > 0) {
                max_change = change;
            }
        }

        current_roots = next_roots;

        // Callback
        if (info.cb) {
            updateInfo(iter, max_change, current_roots);
            info.cb();
        }

        // Check Timeout
        if (new Date().getTime() - start_time > max_time) {
            updateInfo(iter, max_change, current_roots);
            console.log(`roots: Timeout after ${iter} steps.`);
            info.result = null;
            return null;
        }

        // Check Convergence
        if (max_change.cmp(tol) &lt;= 0) {
            updateInfo(iter, max_change, current_roots);
            info.result = current_roots;
            return current_roots;
        }
    }

    // Failure
    updateInfo(max_step, max_change, current_roots);
    console.log(`roots: Failed to converge. Error: ${info.error.toString(10,3)}`);
    info.result = null;
    return null;
};






/**
 * High-precision Function Minimization using Brent's Method (similar to MATLAB's fminbnd).
 *
 * This algorithm finds a local minimum of a function of one variable within a fixed interval.
 * It combines Golden Section Search (linear convergence) with Parabolic Interpolation 
 * (superlinear convergence) for reliability and speed.
 *
 * @param {Function} f - The objective function to minimize.
 *        Must accept a BigFloat argument and return a BigFloat result.
 *
 * @param {number|string|BigFloat} _ax - The start of the search interval.
 * @param {number|string|BigFloat} _bx - The end of the search interval.
 *
 *
 * @param {Object} [info={}] - Configuration and Status object.
 *        Updates in-place with statistics (iterations, execution time, error estimate).
 *        // --- Input Configuration Properties ---
 * @param {number|string|BigFloat} [info._e=1e-30] - Absolute Error Tolerance.
 *
 * @param {number|string|BigFloat} [info._re=info._e] - Relative Error Tolerance.
 *        The convergence criteria is based on the position x, not the function value.
 *        tol = |x| * _re + _e
 * @param {number} [info.max_step=500] - Maximum number of iterations allowed.
 *        If this limit is reached without convergence, the function returns null and logs a warning.
 * @param {number} [info.max_time=60000] - Maximum execution time in milliseconds.
 *        Prevents the function from hanging in infinite loops or extremely slow computations.
 * @param {Function} [info.cb] - Optional callback function.
 *        If defined, this function is called after every iteration. Useful for updating UI progress or logging.
 * @param {boolean} [info.debug] - Optional flag to enable debug logging (implementation dependent).
 *
 *        // --- Output Status Properties (Updated during execution) ---
 * @param {BigFloat|null} info.result - The final found root.
 *        Returns a BigFloat if converged, or null if failed.
 * @param {BigFloat} info.lastresult - The result of the last iteration (current best guess `b`).
 *        Even if convergence fails, this contains the value closest to the root when execution stopped.
 * @param {string} info.eff_result - String representation of the result based on effective precision.
 *        Generated by truncating `lastresult` according to `eff_decimal_precision`.
 * @param {number} info.steps - The number of iterations currently executed.
 * @param {number} info.exectime - The elapsed execution time in milliseconds.
 * @param {BigFloat} info.error - The estimated error bound.
 *        Typically represents half the width of the current search interval (`xm`).
 * @param {BigFloat} info.residual - The absolute value of the function at the current best guess: `|f(x)|`.
 *        Ideally, this value should be close to zero.
 * @param {number} info.eff_decimal_precision - Estimated number of significant decimal digits.
 *        Calculated as `-log10(error)`.
 * @param {Function} info.toString - Helper method.
 *        Returns a formatted string containing steps, error, residual, and execution time.
 * 
 * @returns {BigFloat|null}
 *        Returns the BigFloat x where f(x) is minimized.
 *        Returns `null` if max steps or time limit exceeded.
 */
export function fminbnd(f, _ax, _bx, info = {}) {
    let _e  = info._e ?? 1e-30;
    let _re = info._re ?? _e;

    // 1. Configuration &amp; Constants
    let max_step = info.max_step || 500, // Minimization often takes more steps than root finding
        max_time = info.max_time || 60000;

    if (typeof(_e) !== 'number' || typeof(_re) !== 'number' || typeof(info) !== "object") {
        throw new Error("arguments error");
    }

    const start_time = new Date().getTime();

    // Cache BigFloat constants
    const bf_zero = bfjs.zero;
    const bf_one = bfjs.one;
    const bf_two = bfjs.two;
    const bf_half = bfjs.half;
    
    // Golden Section Ratio: (3 - sqrt(5)) / 2  ≈ 0.381966011...
    // We calculate it at runtime to match current precision
    const bf_golden = bfjs.three.sub(bfjs.bf(5).sqrt()).mul(bf_half);

    // Initial Interval
    let a = bfjs.bf(_ax);
    let b = bfjs.bf(_bx);
    
    // Ensure a &lt; b
    if (a.cmp(b) > 0) {
        let temp = a; a = b; b = temp;
    }

    // Initialization of Brent's variables
    // x: is the point with the very least function value found so far
    // w: is the point with the second least function value
    // v: is the previous value of w
    // u: is the point at which the function has been evaluated most recently
    
    // Start x, w, v at: a + golden_ratio * (b - a)
    let c = b.sub(a);
    let x = a.add(c.mul(bf_golden));
    let w = x;
    let v = x;

    let fx = f(x);
    let fw = fx;
    let fv = fx;

    let d = bf_zero; // Step taken in the iteration before last
    let e = bf_zero; // Step taken in the last iteration

    // Tolerances
    let tol_act = bfjs.bf(_e);
    let tol_rel = bfjs.bf(_re);

    // Helper to sync local variables to info object
    const updateInfo = (iter, errorBound, currentMinVal) => {
        info.exectime = new Date().getTime() - start_time;
        info.steps = iter;
        info.lastresult = x; // Current best position
        info.min_value = currentMinVal; // Current best function value
        info.error = errorBound; // Interval width or step estimate

        // Calculate effective decimal precision of the position x
        if (errorBound.cmp(bf_zero) === 0) {
             info.eff_decimal_precision = bfjs.decimal_precision();
        } else {
             info.eff_decimal_precision = Math.floor(-errorBound.log().f64() / Math.log(10));
        }

        if (info.eff_decimal_precision &lt;= 0) {
            info.eff_decimal_precision = 0;
            info.eff_result = '';
        } else {
            let limit = bfjs.decimal_precision();
            let prec = info.eff_decimal_precision > limit ? limit : info.eff_decimal_precision;
            info.eff_result = x.toString(10, prec);
        }
    };

    info.toString = function() {
        return `xmin=${this.eff_result}, 
      f(xmin)=${this.min_value ? this.min_value.toString(10, 6) : 'N/A'},
      steps=${this.steps}/${max_step}, 
      error=${this.error ? this.error.toString(10, 3) : 'N/A'},
      exectime=${this.exectime}/${max_time}`;
    };

    // 2. Main Loop
    for (let iter = 1; iter &lt;= max_step; ++iter) {
        
        // Midpoint of current interval
        let xm = a.add(b).mul(bf_half);
        
        // Calculate tolerance based on current x magnitude
        // tol1 = |x| * tol_rel + tol_act
        let tol1 = x.abs().mul(tol_rel).add(tol_act);
        let tol2 = tol1.mul(bf_two);

        // Check for Convergence
        // Stop if the interval |b-a| is small enough (roughly &lt; 2*tol)
        // Strictly: |x - xm| &lt;= (2*tol1 - 0.5*(b-a))
        // Simplified robust check: Is max distance from x to a or b &lt;= 2*tol1?
        let dist = x.sub(xm).abs().add(b.sub(a).mul(bf_half));
        
        if (dist.cmp(tol2) &lt;= 0) {
            updateInfo(iter, dist, fx);
            info.result = x;
            return x;
        }

        // Callback and Timeout Check
        if (info.cb) {
            updateInfo(iter, dist, fx);
            info.cb();
        }
        if (new Date().getTime() - start_time > max_time) {
            updateInfo(iter, dist, fx);
            console.log("fminbnd: Timeout reached.");
            info.result = null;
            return null;
        }

        // --- Determine Step ---
        let p = bf_zero;
        let q = bf_zero;
        let r = bf_zero;
        let new_step = bf_zero;

        // Is Parabolic Interpolation possible?
        // Needs |e| > tol1 (previous step was significant)
        if (e.abs().cmp(tol1) > 0) {
            // Parabolic fit using x, w, v
            // r = (x - w) * (fx - fv)
            // q = (x - v) * (fx - fw)
            // p = (x - v) * q - (x - w) * r
            // q = 2.0 * (q - r)
            
            r = x.sub(w).mul(fx.sub(fv));
            q = x.sub(v).mul(fx.sub(fw));
            p = x.sub(v).mul(q).sub(x.sub(w).mul(r));
            q = q.sub(r).mul(bf_two);

            if (q.cmp(bf_zero) > 0) {
                p = p.neg();
            }
            q = q.abs();

            let etemp = e;
            e = d;

            // Check if parabolic fit is acceptable
            // 1. p must be within interval (a, b) specific bounds: |p| &lt; |q * 0.5 * (a/b - x)|
            //    Strictly: (abs(p) &lt; abs(0.5*q*etemp)) AND (p > q*(a-x)) AND (p &lt; q*(b-x))
            // 2. Step size must be shrinking
            
            let is_parabolic_valid = true;
            
            // Condition 1: Step smaller than half of previous-previous step? (Convergence check)
            if (p.abs().cmp(q.mul(etemp).abs().mul(bf_half)) >= 0) {
                is_parabolic_valid = false;
            } 
            // Condition 2: Must land within (a, b)
            // p/q calculates the offset from x. x + p/q must be in [a, b]
            // Actually, we usually require it to be within [a+tol, b-tol]
            else {
                let p_bound_a = q.mul(a.sub(x));
                let p_bound_b = q.mul(b.sub(x));
                
                // Since q > 0, we can compare directly
                if (p.cmp(p_bound_a) &lt;= 0 || p.cmp(p_bound_b) >= 0) {
                    is_parabolic_valid = false;
                }
            }

            if (is_parabolic_valid) {
                // Accept Parabolic Step
                d = p.div(q);
                new_step = d;
                
                // If step lands very close to bounds, adjust to ensure we don't violate precision
                let u_tentative = x.add(d);
                if (u_tentative.sub(a).cmp(tol2) &lt; 0 || b.sub(u_tentative).cmp(tol2) &lt; 0) {
                    // d = sign(xm - x) * tol1
                    let sign = xm.sub(x).cmp(bf_zero) >= 0 ? bf_one : bf_one.neg();
                    d = tol1.mul(sign);
                }
            } else {
                // Reject Parabolic, switch to Golden Section
                e = (x.cmp(xm) >= 0 ? a : b).sub(x);
                d = bf_golden.mul(e);
            }
        } else {
            // Golden Section Step (first iteration or small steps)
            e = (x.cmp(xm) >= 0 ? a : b).sub(x);
            d = bf_golden.mul(e);
        }

        // --- Apply Step ---
        // Ensure we move at least tol1 to allow convergence check to pass eventually
        // u = x + d (if |d| >= tol1) else x + sign(d)*tol1
        if (d.abs().cmp(tol1) >= 0) {
            new_step = d;
        } else {
            let sign = d.cmp(bf_zero) >= 0 ? bf_one : bf_one.neg();
            new_step = tol1.mul(sign);
        }
        
        let u = x.add(new_step);
        let fu = f(u);

        // --- Update Brackets (a, b) and Points (x, w, v) ---
        if (fu.cmp(fx) &lt;= 0) {
            // Found a new minimum!
            if (u.cmp(x) >= 0) {
                a = x;
            } else {
                b = x;
            }
            v = w; fv = fw;
            w = x; fw = fx;
            x = u; fx = fu;
        } else {
            // Not a new minimum, but use it to tighten interval
            if (u.cmp(x) &lt; 0) {
                a = u;
            } else {
                b = u;
            }
            
            // Should we update w or v?
            if (fu.cmp(fw) &lt;= 0 || w.cmp(x) === 0) {
                v = w; fv = fw;
                w = u; fw = fu;
            } else if (fu.cmp(fv) &lt;= 0 || v.cmp(x) === 0 || v.cmp(w) === 0) {
                v = u; fv = fu;
            }
        }
    }

    // 3. Exit (Max steps)
    let final_dist = x.sub(a.add(b).mul(bf_half)).abs().add(b.sub(a).mul(bf_half));
    updateInfo(max_step, final_dist, fx);
    
    console.log(`fminbnd: Failed to converge after ${max_step} steps.`);
    info.result = null;
    return null;
}</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a> on Sat Feb 14 2026 14:22:44 GMT+0800 (中国标准时间) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
